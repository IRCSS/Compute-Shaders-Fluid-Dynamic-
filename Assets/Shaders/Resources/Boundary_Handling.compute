// DEALING WITH THE BOUNDARY CONDITIONS TO CONTAIN THE SIMULATION

//____________________________________________________________________________________
// KERNELS
#pragma kernel NeuMannBoundary

//____________________________________________________________________________________
// DECLERNATIONS
#include "FluidDynamicCommonUniforms.cginc"

//____________________________________________________________________________________
// HELPER FUNCTIONS
#include "FluidDynamicUtility.cginc"

//____________________________________________________________________________________
// MAIN FUNCTIONS

// NEUMANN DECLERNATIONS

RWStructuredBuffer<float4> _field_to_contain;
float                      _scale;               // On, velocity field = -1, Presure Field = 1, Denisty = 0, ... 
                                                 // For veloicty you want to have opposite for partials to be zero. 
                                                 // Pressure needs to be the same, otherwise you get acceleration, and denisty is a choice thing

//----------------------------------------------------------------------------
// Function         : NeuMannBoundary
// Description      : The boundaries need to ensure that partiaul(u)/partial(n) is zero, where
//                    n is the normal of the boundary. Baisicly set the velocity on borders to
//                    the negative of the cell right next to it in the direction of the normal
//                    This is dispatched once on the edges of the edges of the vector field.
//                    so each thread maps to one of the edge cells. So i_Resolution * 4. It is 
//                    a one dimensional dispatch
//----------------------------------------------------------------------------


[numthreads(256,1,1)]
void NeuMannBoundary(uint3 id : SV_DispatchThreadID)
{

    uint  case_id = id.x / i_Resolution;               // 0 = left_corner, 1 = right_corner , 2 = top_corner, 3 = bottom_corner
    uint  rest    = id.x - case_id * i_Resolution;     // In the dispatch, this is used to map the threads in each case to a cell on a border

    uint2 coord   = uint2(0, 0);
    uint2 offset  = uint2(0, 0);

    if (case_id == 0) { coord = uint2(0,                rest            );   offset = uint2( 1,  0); }
    if (case_id == 1) { coord = uint2(i_Resolution - 1, rest            );   offset = uint2(-1,  0); }
    if (case_id == 2) { coord = uint2(rest,             i_Resolution - 1);   offset = uint2( 0, -1); }
    if (case_id == 3) { coord = uint2(rest,             0               );   offset = uint2( 0,  1); }

    _field_to_contain[id2Dto1D(coord)] = _scale * _field_to_contain[id2Dto1D(coord + offset)];    // Since the threads are only writing on the border cells, there is no racing condition here

}
