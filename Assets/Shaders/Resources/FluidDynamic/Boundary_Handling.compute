// DEALING WITH THE BOUNDARY CONDITIONS TO CONTAIN THE SIMULATION

//____________________________________________________________________________________
// KERNELS
#pragma kernel NeuMannBoundary
#pragma kernel debugBoundaryAlgo

//____________________________________________________________________________________
// DECLERNATIONS
#include "FluidDynamicCommonUniforms.cginc"

//____________________________________________________________________________________
// HELPER FUNCTIONS
#include "FluidDynamicUtility.cginc"

//____________________________________________________________________________________
// MAIN FUNCTIONS

// NEUMANN DECLERNATIONS

RWStructuredBuffer<float4> _neumaboundary_field_to_contain;
float                      _neumaboundary_scale;       // On, velocity field = -1, Presure Field = 1, Denisty = 0, ... 
                                                       // For veloicty you want to have opposite for partials to be zero. 
                                                       // Pressure needs to be the same, otherwise you get acceleration, and denisty is a choice thing

//----------------------------------------------------------------------------
// Function         : NeuMannBoundary
// Description      : The boundaries need to ensure that partiaul(u)/partial(n) is zero, where
//                    n is the normal of the boundary. Baisicly set the velocity on borders to
//                    the negative of the cell right next to it in the direction of the normal
//                    This is dispatched once on the edges of the edges of the vector field.
//                    so each thread maps to one of the edge cells. So i_Resolution * 4. It is 
//                    a one dimensional dispatch
//----------------------------------------------------------------------------


[numthreads(256,1,1)]
void NeuMannBoundary(uint3 id : SV_DispatchThreadID)
{

    int  case_id = id.x / i_Resolution;               // 0 = left_corner, 1 = right_corner , 2 = top_corner, 3 = bottom_corner
    int  rest    = id.x - case_id * i_Resolution;     // In the dispatch, this is used to map the threads in each case to a cell on a border

    int2 coord   = uint2(0, 0);
    int2 offset  = uint2(0, 0);

    if (case_id == 0) { coord = int2(0,                rest            );   offset = int2( 1,  0); }
    if (case_id == 1) { coord = int2(i_Resolution - 1, rest            );   offset = int2(-1,  0); }
    if (case_id == 2) { coord = int2(rest,             i_Resolution - 1);   offset = int2( 0, -1); }
    if (case_id == 3) { coord = int2(rest,             0               );   offset = int2( 0,  1); }

    _neumaboundary_field_to_contain[id2Dto1D(coord)] = _neumaboundary_scale * _neumaboundary_field_to_contain[id2Dto1D(coord + offset)];    // Since the threads are only writing on the border cells, there is no racing condition here

}

// _____________________________________

// DEBUG DECLERNATIONS

RWTexture2D<float4> _boundary_debug_texture;

//----------------------------------------------------------------------------
// Function         : debugBoundaryAlgo
// Description      : This program debugs the algorithm used for determining the borders
//----------------------------------------------------------------------------


[numthreads(256, 1, 1)]
void debugBoundaryAlgo(uint3 id : SV_DispatchThreadID) 
{
    int  case_id = id.x / i_Resolution;               // 0 = left_corner, 1 = right_corner , 2 = top_corner, 3 = bottom_corner
    int  rest    = id.x - case_id * i_Resolution;     // In the dispatch, this is used to map the threads in each case to a cell on a border

    int2 coord   = int2(0, 0);
    int2 offset  = int2(0, 0);

    float4 borderColor;

    if (case_id == 0) { coord = int2(0,                rest            );   offset = int2( 1,  0);  borderColor = float4(1.,0.,0.,1.);}
    if (case_id == 1) { coord = int2(i_Resolution - 1, rest            );   offset = int2(-1,  0);  borderColor = float4(0.,1.,0.,1.);}
    if (case_id == 2) { coord = int2(rest,             i_Resolution - 1);   offset = int2( 0, -1);  borderColor = float4(0.,0.,1.,1.);}
    if (case_id == 3) { coord = int2(rest,             0               );   offset = int2( 0,  1);  borderColor = float4(0.,1.,1.,1.);}

    _boundary_debug_texture[coord] = borderColor;

}