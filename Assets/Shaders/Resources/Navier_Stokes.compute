// This file contains the Navier Stokes equation. The Navier Stokes equation are of the form:
// new_Divergent_vector_field = advection + diffusion + external_forces
// The diffusion is only a linear equation system which is solved by calling the solver several times
// hence this file only contains implemmentation for adding external forces and advection
// plus projection


//____________________________________________________________________________________
// KERNELS

#pragma kernel advection
#pragma kernel divergence
#pragma kernel calculate_divergence_free

//____________________________________________________________________________________
// COMMON DECLERNATIONS

#include "FluidDynamicCommonUniforms.cginc"


//____________________________________________________________________________________
// HELPER FUNCTIONS

#include "FluidDynamicUtility.cginc"

//____________________________________________________________________________________
// MAIN FUNCTIONS

// ADVECTION DECLERNATIONS

float                      _dissipationFactor;                              // This factor determines how fast the quantities dissapate over time. 

StructuredBuffer<float4>   _velocity_field_buffer;                          // The velocity field which does the carrying
StructuredBuffer<float4>   _field_to_advect_buffer;                         // this is the field which is being carried off by the vector field, it can be temperature, dye, or the velocity itself

RWStructuredBuffer<float4> _new_advected_field;                             // The results of advection is written on this field

//----------------------------------------------------------------------------
// Function         : Advection
// Description      : Advection is the part of the equation that is responsible for carrying
//                    things along the fluid field. This can be head, densities or even the 
//                    the velocity of the fluid itself. It works by tracing backwards from each fragment
//                    along the velocity field, and moving the passive value at its destination
//                    forward to the starting point.It performs bilinear interpolation at the
//                    destination to get a smooth resulting field. It also clamps the velocities
//                    on the bounderies.
//----------------------------------------------------------------------------

[numthreads(16,16,1)]                                                       // Runs once per simulation grid
void advection(uint3 id : SV_DispatchThreadID)                              
{                                                                           
    uint2  coord = id.xy;                                                   // One to one mapping between the dispatch ids and the coordinate
    
    float2 advection_source_coord = (float2)coord -                         // Trace backwards along trajectory
                                  i_timeStep *                              // distance = velocity * time, this is the time part 
                                  _velocity_field_buffer[id2Dto1D(coord)] * // This is the velocity part
                                  (1. / (float)i_Resolution) ;              // The speed is in the unite of grids, but since the grid might not be unit-scale, we need to also scale by the grid cell size.
    
    
    advection_source_coord = clamp(advection_source_coord,                  // Handling the case where the velocity traces back to outside the bounds of the buffer
                                   0.5, i_Resolution - 0.5);                // left hand side ensures the smallest element to read is element , and the biggest n-1
    
    _new_advected_field[id2Dto1D(coord)] = _dissipationFactor *             // Disspation factor 1 = lasts forever, 0 = instantly dissipates, dunno how physcilly accurate this is. 
                                           StructuredBufferBilinearLoad(_field_to_advect_buffer, advection_source_coord);

}


// _______________________________

// DIVERGENCE DECLERNATIONS

StructuredBuffer<float4>     _vector_field;                                 // This is the vector field which we want to calculate the divergence of, the members of the array are quanteties in this vector field
RWStructuredBuffer<float4>   _divergence_values;                            // The results are written to this buffer


//----------------------------------------------------------------------------
// Function         : divergence
// Description      : Divergence is a physical measure of how much stuff flow in 
//                    or out of a point in a vector field. Since fluids can not be 
//                    compressed, the fluid field needs to have a divergence of 0 everywhere.
//                    The quanteties we calculate are at first not divergence free, however by
//                    calculating its divergence and using a possion equation we can split up the 
//                    the vector field in a divergence and curl components, and keep the curl one.
//                    
//                    Divergence = partial(field.x)/ partial(x) + partial(field.y)/partial(y)
//                    The partial(x) = partial(y) = 1.0/(2.0*cellSize)
//----------------------------------------------------------------------------

[numthreads(16, 16, 1)]                                                     // runs once per cell of the vector field
void divergence(uint3 id : SV_DispatchThreadID)
{                                                                           
    float partialXY = 1. / (2. * i_Resolution);
    uint2 coord     = id.xy;                                                // one to one mapping between thread ids in the dispatch and the structured buffer

    float4 left     = _vector_field[id2Dto1D(coord - uint2(1, 0))];
    float4 right    = _vector_field[id2Dto1D(coord + uint2(1, 0))];
    float4 bottom   = _vector_field[id2Dto1D(coord - uint2(0, 1))];
    float4 top      = _vector_field[id2Dto1D(coord + uint2(0, 1))];

    _divergence_values[id2Dto1D(coord)] = 
                       partialXY * (right - left + top - bottom);
}
    
// _______________________________


//----------------------------------------------------------------------------
// Function         : calculate_divergence_free
// Description      : The gradient function calculates the gradient of a scalar vector field
//                    After the 
//----------------------------------------------------------------------------
[numthreads(16, 16, 1)]                                                     // runs once per cell of the vector field
void calculate_divergence_free(uint3 id : SV_DispatchThreadID)
{                                                                           
  
}